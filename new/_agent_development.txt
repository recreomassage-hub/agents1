Система агентов для разработки. Она состоит из команды агентов. Один агент занимается оркестрацией процесса разработки: он ставит задачи другим агентам и принимает их результат. И на основе этого определяет, что делать дальше. Если он видит, что необходимо подключить человека для ответов на вопросы и спорная ситуация, он останавливает процедуру и ждёт ответов на вопросы.

Первый агент — это аналитик. Он принимает на вход высокоуровневую постановку задачи и пишет по ней ТЗ. Основная часть ТЗ — это список юзер-кейсов. По каждому юзер-кейсу приводится сценарий его работы и участники (актеры). Пишется основной и альтернативные сценарии. Также аналитик пишет критерии приёмки по каждому юзер-кейсу.

Следующий участник — архитектор. Архитектор берёт ТЗ и проектирует архитектуру системы. Сначала он определяет функциональную архитектуру системы: какие функциональные компоненты в этой системе присутствуют и какие функции они предоставляют. Дальше проектирует системную архитектуру, то есть разделяет (выделяет) компоненты системы и соотносит их с функциями из функциональной архитектуры. Описывает интерфейсы (как внешние, так и внутренние между компонентами), а также описывает стек используемых технологий. Фактически на выходе получаем следующее.

Следующая роль — это техлид-планировщик. Основная задача техлида-планировщика — это формулировка задач, по которым остальные участники команды смогут реализовать, проверить и развернуть систему. Планировщик выдаёт один документ, содержащий низкоуровневый план, в котором перечислены задачи с кратким описанием и дедлайнами, а также последовательность выполнения этих задач. По каждой задаче планировщик создаёт в отдельном файле развёрнутое описание, где более детально, технически описывает, что нужно сделать. Но не дублирует работу разработчиков, то есть не пишет код. В описании задачи можно перечислить названия классов, методов, их параметры и словами кратко описать логику работы. Не нужно пытаться словами написать весь код.


Что еще важно, Архитектор, Аналитик и Планировщик код не пишут. Также в общем плане и описание задач от Планировщика нужно указывать ссылки на юзкейсы, которые эти задачи покрывают. Планировщик также пишет задачи на разработку тестов и на развертывание системы. Архитектор должен дать рекомендации по развертыванию.

Планировщик принимает на вход ТЗ и архитектуру, а также, если это доработка существующей системы, должен внимательно изучить документацию и работать с кодом проекта, чтобы четко указать в задачах в каких конкретных местах нужно внести изменения. Разработчик и любой исполнитель по задачам планировщика не должен думать, где именно вносить изменения. Он лишь должен делать реализацию по текстовому описанию не прорабатывая общую структуру проекта. Также есть роли ревьюера ТЗ. Основная функция ревьюера ТЗ это: Оценить насколько ТЗ полно описывает поставленную задачу и в целом соотносится с тем что уже сделано в проекте. Ревьюер архитектуры также оценивает насколько архитектура адекватно соответствует постановке задачи и ТЗ и ложится на уже существующие функционалы архитектуры проекта. Для роли планировщика рецензент не требуется. Следующая роль это разработчик. Мы считаем что разработчик универсальная роль для выполнения задач на разработку и на написание автотестов. Вообще планировщик в каждую задачную разработку должен приложить список тест кейсов которые не должны проходить после выполнения задачи.

Планировщик должен таким образом формулировать задачи, что система в целом, даже с первой задачи, должна работать так, как будто разработка уже полностью сделана. То есть все изменения, новые классы, функции и параметры должны быть добавлены как можно раньше в первых же задачах. Но это должны быть заглушки, которые ничего не делают, либо какой-то захардкоженный код возвращают реализация должна уже идти в последующих задачах и также тесты нужно писать сразу end-to-end с учетом того что реализация захардкожена. И дальше мы двигаемся сверху вниз дописывая функционал и модифицируя тесты, то есть добавляем уже более частные тест кейсы в наши тесты. То есть важно что мы не снизу вверх реализовываем систему когда мы пишем отдельно частные функции а потом есть риск что все это не срастётся. А мы идем от крупных сценариев основных, веток так чтобы основной функционал у нас работал как можно раньше его можно было проверить end-to-end.

Разработчик должен четко следовать указаниям из задач. Он должен писать структурированный, документированный код с использованием лучших практик разработки, избегать дублирование уже существующего кода, лучше добавлять параметры в существующие методы, чем добавлять аналогичные методы с немножечко другой функциональностью. При написании тестов разработчик должен максимально задействовать имеющийся функционал и минимизировать использование основной задачи разработчика — написать тестируемый код, который он может проверить, чтобы убедиться, что все работает. После выполнения задачи разработчик должен прогонять указанные планировщиком задачи тесты, не только тесты на новый функционал, но и регресс, чтобы убедиться, что он ничего попутно не сломал. Так же разработчик может принимать на вход не задачу, а результат работы рецензента кода, в этом случае это будет список замечаний. Также разработчик может принимать на вход задача на исправление по результатам запуска тестов вне рамок выполнения задачи.

Если любой из агентов сталкивается со сложностями и возникают вопросы, он должен добавить в список открытых вопросов файлы. В случае разработчика список открытых вопросов должен просто вернуться в качестве ответа. Если оркестратор получает список открытых вопросов, он должен останавливать работу и ждать пока пользователь ответит на эти вопросы, также архитектор и аналитик могут принимать на вход замечания от своих рецензентов. В этом случае они должны исправить свои документы. С учетом этих замечаний, но не трогать части, которые не касаются этих замечаний. Это уже касается и разработчика. Разработчик должен только исправлять замечания от рецензента, но не рефакторить попутно код, так же как и при исправлении замечаний по тесту.

Чем на более раннем этапе мы находимся, тем больше нужно уделять внимание неясным моментам и вопросам, поскольку неразрешённая неопределённость на начальном этапе может привести к тому, что проект в целом не сойдётся. Поэтому роль аналитика должна уделять особое внимание… выяснению всех нюансов. Архитектор также должен уделять много внимания открытым вопросам и уточнениям. Планировщик уже в целом может задавать меньше вопросов, но если он видит нестыковки или не понимает и сталкивается с сложностями, он тоже должен задать вопросы Разработчик тоже может задавать вопросы, но в целом он всё-таки должен стараться выполнить задачи по описанию.

Разработчик в своих задачах также должен актуализировать как общее описание проекта так и для облегчения работы агента архитектору, аналитику и планировщику в дальнейшем в каждый каталог в проекте добавлять документацию с описанием содержимого каталога какие там есть файлы какие есть функции и вкратце что они делают также в проекте должно быть как человека читаемое описание так и больше ориентированное агентов описания общая система если описание получается слишком большим его нужно структурировать указывая в общем документе ссылки на отдельные документы с более детальным описанием.


Ревьюер кода должен проверять соответствие полученного кода постановки задачи, а также целом отслеживать непротиворечивость изменений существующим функционалу проекта и другим задачам. Разработчик должен выдавать не только код функциональности и тестов но и прикладывать отчет о выполненных тестах чтобы рецензент не запускает самостоятельно тесты мог убедиться в том что разработчик проверил свою работу. Тут важно, чтобы планировщик в описании задачи повышенное внимание уделил описанию того, какие тесты нужно сделать либо доработать (как в случае с hard-code каких-то кусков и их доработка существующей задачи), чтобы был реальный функционал, а не заглушка, и чтобы тесты все эти изменения проверяли, особенно сквозные тесты сценариев. Нужно запускать после каждой задачи, чтобы убедиться, что сценарий сходится, а не расходится. А reviewer кода также должен особое внимание уделять проверке сходимости изменений, что e2e-тесты проходят и куски заглушки заменяются на реально работающий код.

По роли оркестратора нужно сделать промты отдельные для каждого случая.

В случае роли аналитика он должен брать текущее описание проекта если это уже существующий проект и верхневую постановку задачи от пользователя и инициировать работу агента аналитика агент-аналитик должен на выходе давать ссылку на полученные ТЗ в файле то есть он должен сохранить его файл и так же указывать на наличие блокирующих замечаний. В этом случае оркестратор получив результат работы агент-аналитика сможет понять можно ли продолжать работу или нужно ждать ответы пользователей на вопросы если от аналитика нет блокирующих вопросов оркестратор должен инициировать работу агента рецензента ТЗ и получать от него ссылку. Результат review.tz это файл со списком замечаний. Оркестратор должен проверять наличие замечания, если такие замечания есть, то передавать на рецензирование, на исправление опять агенту-аналитику, получать от него исправление и второй раз передать. На review-рецензенту цикл повторяется максимум 2 раза, то есть 2 рецензирования, 2 ответа. Если вдруг после второго рецензирования остаются критичные замечания, нужно останавливать работу и подключать пользователя. Аналогичным образом с 2 циклами поступаем с архитектурой. После того как архитектура готова, оркестратор должен ставить задачу планировщику. Планировщик также создает файлы и на выходе возвращает список файлов.

Все-таки еще нужна роль рецензента плана, но он не должен сильно вникать в содержимое описания задач. Основная роль рецензента плана — это убедиться, что, во-первых, все пункты плана покрывают все юзкейсы из TZ, и, второе, то, что по форме на все задачи есть детальное описание в отдельных файлах. Если этого нет, то рецензент плана должен выдавать файл со списком замечаний, и агент-планировщик (оркестратор) должен ставить задачу агенту-планировщику на доработку плана (не больше одной итерации). Если после первой итерации остались критичные замечания (нужно), то есть после второго review плана нужно останавливать работы и подключать пользователей. После того как план готов, оркестртор должен ставить по очереди задачи из плана агенту-разработчику. Разработчик соответственно вносит изменения в код, прикладывает результаты проверки, и оркестртор передает изменения и результаты проверки рецензенту кода. Рецензент кода может вернуть замечание уже не файлом, просто текстом. При наличии замечаний оркестртор передает их агенту-разработчику. Здесь тоже только один цикл, то есть разработка → review → разработка. В случае аналитика получается два цикла («аналитик → review → аналитик → review»), и так же в случае архитектора (два цикла). В случае планировщика получается составление плана → review → корректировка → review.